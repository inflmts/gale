#
# Bash shell initialization file.
#

# quit unless interactive
# apparently needed for rcp or scp or something
[[ $- != *i* ]] && return

__echo() { printf '%s\n' "$1"; }
__diag() { printf >&2 '%s\n' "$1"; }
__warn() { printf >&2 'warning: %s\n' "$1"; }
__err() { printf >&2 'error: %s\n' "$1"; }

if [[ -z $GALE_COLORS ]]; then
  # autodetect number of colors using tput
  GALE_COLORS=$(tput colors 2>/dev/null) || GALE_COLORS=0
fi

# setup colors for ls (and tree)
eval "$(dircolors)"

# FUNCTIONS & ALIASES
# ==============================================================================

alias grep='grep --color=auto'
#alias date='date +"%a %Y-%m-%d %I:%M %p"'

alias sysleep='systemctl suspend'
alias userctl='systemctl --user'
alias md='mkdir -pv'

gale_ls() {
  LC_COLLATE=C command ls -h --group-directories-first --color=auto "$@"
}

alias ls='gale_ls'
alias lsa='gale_ls -A'
alias ll='gale_ls -l'
alias lla='gale_ls -lA'

gale_tree() {
  if [[ -t 1 ]]; then
    LC_COLLATE=C command tree --dirsfirst -C "$@" | less -FXSRMKi
  else
    LC_COLLATE=C command tree --dirsfirst -n "$@"
  fi
}

alias tree='gale_tree'
alias treea='gale_tree -a'
alias treed='gale_tree -d'
alias treeda='gale_tree -da'

# display the function's arguments
argv() {
  __echo "$# argument(s):"
  if [[ $# -gt 0 ]]; then
    printf '%q\n' "$@"
  fi
}

# daemonize a process, redirecting stdout and stderr to /dev/null
# and closing stdin
fork() {
  "$@" <&- &>/dev/null & disown
}

# same as fork but exits the shell afterwards
forkx() {
  "$@" <&- &>/dev/null & disown
  exit
}

# BLOCK DEVICES

# include file system information
lsfs() {
  command lsblk -o NAME,FSTYPE,LABEL,FSUSED,FSUSE%,FSSIZE,MOUNTPOINTS "$@"
}

# include GPT partition information
lsgpt() {
  command lsblk -o NAME,TYPE,RM,SIZE,PARTUUID,PARTLABEL "$@"
}

# cdnew <dir>
#
#   Create (recursively) and change to directory <dir>.
#
cdnew() {
  if [[ $# -eq 1 ]]; then
    mkdir -vp -- "$1" && cd -- "$1"
  else
    __diag 'usage: cdnew <dir>'
    return 1
  fi
}

gale_resolve_block_device() {
  case $1 in
    l=*)
      __echo "/dev/disk/by-label/${1#*=}"
      ;;
    pl=*)
      __echo "/dev/disk/by-partlabel/${1#*=}"
      ;;
    /*)
      __echo "$1"
      ;;
    *)
      __err "invalid block device: $1"
      return 1
      ;;
  esac
}

# udmount <source>
#
#   Mount <source> with udisksctl.
#
udmount() {
  local source
  if [[ $# -ne 1 ]]; then
    __diag 'usage: udmount <source>'
    return 1
  fi
  source=$(gale_resolve_block_device "$1") || return
  udisksctl mount -b "$source"
}

# udumount <source>
#
#   Unmount <source> with udisksctl.
#
udumount() {
  local source
  if [[ $# -ne 1 ]]; then
    __diag 'usage: udeject <source>'
    return 1
  fi
  source=$(gale_resolve_block_device "$1") || return
  udisksctl unmount -b "$source"
}

# lspath
#
#   List the contents of the $PATH environment variable.
#
lspath() {
  local -
  local ifs ent
  ifs=$IFS
  IFS=:
  set -f
  for ent in $PATH; do
    __echo "${ent/#"$HOME"/\~}"
  done
  IFS=$ifs
}

# lsenv
#
#   Sorts and lists exported environment variables.
#
lsenv() {
  env \
      | LC_ALL=C sort -t '=' -k 1 \
      | sed $'s/^/\033[1m/; s/=/=\033[0m/'
}

# cdn3 [<option>...] [<path>]
#
#   n3 wrapper activating cd on quit.
#
cdn3() {
  local tmpfile excode
  tmpfile=$(mktemp /tmp/n3.XXXXX)
  NNN_TMPFILE=$tmpfile command n3 "$@"
  excode=$?
  [[ -f $tmpfile ]] && . "$tmpfile"
  rm -f "$tmpfile"
  return "$excode"
}

mksh() {
  if [[ $# -ne 1 ]]; then
    __diag 'usage: mksh <file>'
    return 1
  fi
  __echo '#!/bin/sh' > "$1" \
    && chmod +x -- "$1"
}

mpv-audio() {
  mpv --no-audio-display "$@"
}

# BANNER
# ==============================================================================

( unset PRETTY_NAME

  # source os-release in a subshell to avoid polluting our variable space
  if [[ -e /etc/os-release ]]; then
    . /etc/os-release
  elif [[ -e /usr/lib/os-release ]]; then
    . /usr/lib/os-release
  fi

  tbold=$'\033[1m'
  treset=$'\033[0m'

  printf -v time '%(%a %Y %b %d %I:%M %p)T'
  printf -v hour '%(%k)T'
  if [[ $hour -lt 5 ]]; then
    timedesc=evening
  elif [[ $hour -lt 12 ]]; then
    timedesc=morning
  elif [[ $hour -lt 18 ]]; then
    timedesc=afternoon
  else
    timedesc=evening
  fi

  __echo
  __echo "  ${tbold}System:${treset} $(uname -srm)${PRETTY_NAME:+ ($PRETTY_NAME)}"
  __echo "  ${tbold}Terminal:${treset} ${TERM:-(unknown)} ($GALE_COLORS colors)"
  __echo "  ${tbold}Time:${treset} $time. Good $timedesc."
  __echo
)

# PROMPT
# ==============================================================================

# if the last command exited unsuccessfully, show the exit code
gale_show_excode() {
  local code="$?"
  local esc=$'\033'
  if [[ $code -gt 0 ]]; then
    if [[ $GALE_COLORS -ge 256 ]]; then
      __echo "$esc[0;38;5;203;48;5;88m exit $code $esc[0m"
    else
      __echo "$esc[0;31m[exit $code]$esc[0m"
    fi
  fi
}

# update the terminal title
gale_update_title() {
  printf '\033]2;%s\003\\' "${USER}@${HOSTNAME%%.*} ${PWD/#$HOME/\~}"
}

PS1=
PS1+='\[\e[0;1m\]'

# autodetect nnn
if [[ $NNNLVL ]]; then
  if [[ $GALE_COLORS -ge 256 ]]; then
    PS1+='\[\e[37;45m\] nnn($NNNLVL) '
  else
    PS1+='\[\e[35m\]nnn($NNNLVL) '
  fi
fi

if [[ $GALE_COLORS -ge 256 ]]; then
  PS1+='\[\e[37;48;5;196m\] \u@\h '
  PS1+='\[\e[48;5;124m\] \w '
  PS1+='\[\e[22;38;5;203;48;5;88m\]\$\[\e[0m\] '
else
  PS1+='\[\e[31m\]\u@\h \[\e[34m\]\w \[\e[0m\]\$ '
fi

PROMPT_COMMAND=(gale_show_excode gale_update_title)

# vim:ft=bash
