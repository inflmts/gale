#
# Bash initialization file
#
# This file is part of Gale.
#
# Local changes should be made at:
#
#   ~/.config/gale/bashrc
#
# Note that this configuration file is sourced regardless of whether or not the
# session is interactive.
#

if [[ -f ~/.config/gale/bashrc ]]; then
  . ~/.config/gale/bashrc
fi

# quit unless interactive
# apparently needed for rcp or scp or something
[[ $- != *i* ]] && return

gale_echo() { command printf '%s\n' "$1"; }
gale_diag() { command printf >&2 '%s\n' "$1"; }
gale_warn() { command printf >&2 'warning: %s\n' "$1"; }
gale_err() { command printf >&2 'error: %s\n' "$1"; }

if [[ -z $GALE_COLORS ]]; then
  # autodetect number of colors using tput
  GALE_COLORS=$(tput colors 2>/dev/null) || GALE_COLORS=0
fi

# setup colors for ls (and tree)
eval "$(dircolors)"

# FUNCTIONS & ALIASES
# ==============================================================================

alias grep='grep --color=auto'
#alias date='date +"%a %Y-%m-%d %I:%M %p"'

alias sysleep='systemctl suspend'
alias userctl='systemctl --user'
alias md='mkdir -pv'

gale_ls()
{
  LC_COLLATE=C command ls -h --group-directories-first --color=auto "$@"
}

alias ls='gale_ls'
alias lsa='gale_ls -A'
alias ll='gale_ls -l'
alias lla='gale_ls -lA'

gale_tree()
{
  if [[ -t 1 ]]; then
    LC_COLLATE=C command tree --dirsfirst -C "$@" | less -FXSRMKi
  else
    LC_COLLATE=C command tree --dirsfirst -n "$@"
  fi
}

alias tree='gale_tree'
alias treea='gale_tree -a'
alias treed='gale_tree -d'
alias treeda='gale_tree -da'

# display the function's arguments
argv()
{
  gale_echo "$# argument(s):"
  if [[ $# -gt 0 ]]; then
    printf '%q\n' "$@"
  fi
}

# fork processes using setsid(1)
.f() { setsid -f -- "$@" >/dev/null 2>&1; }
.fx() { setsid -f -- "$@" >/dev/null 2>&1 && exit; }

# BLOCK DEVICES

# include file system information
lsfs()
{
  command lsblk -o NAME,FSTYPE,LABEL,FSUSED,FSUSE%,FSSIZE,MOUNTPOINTS "$@"
}

# include GPT partition information
lsgpt()
{
  command lsblk -o NAME,TYPE,RM,SIZE,PARTUUID,PARTLABEL "$@"
}

# cdnew <dir>
#
#   Create (recursively) and change to directory <dir>.
#
cdnew()
{
  if [[ $# -eq 1 ]]; then
    mkdir -vp -- "$1" && cd -- "$1"
  else
    gale_diag 'usage: cdnew <dir>'
    return 1
  fi
}

gale_resolve_block_device()
{
  case $1 in
    l=*)
      gale_echo "/dev/disk/by-label/${1#*=}"
      ;;
    pl=*)
      gale_echo "/dev/disk/by-partlabel/${1#*=}"
      ;;
    /*)
      gale_echo "$1"
      ;;
    *)
      gale_err "invalid block device: $1"
      return 1
      ;;
  esac
}

# udmount <source>
#
#   Mount <source> with udisksctl.
#
udmount()
{
  local source
  if [[ $# -ne 1 ]]; then
    gale_diag 'usage: udmount <source>'
    return 1
  fi
  source=$(gale_resolve_block_device "$1") || return
  udisksctl mount -b "$source"
}

# udumount <source>
#
#   Unmount <source> with udisksctl.
#
udumount()
{
  local source
  if [[ $# -ne 1 ]]; then
    gale_diag 'usage: udeject <source>'
    return 1
  fi
  source=$(gale_resolve_block_device "$1") || return
  udisksctl unmount -b "$source"
}

# lspath
#
#   List the contents of the $PATH environment variable.
#
lspath()
{
  local -
  local ifs ent
  ifs=$IFS
  IFS=:
  set -f
  for ent in $PATH; do
    gale_echo "${ent/#"$HOME"/\~}"
  done
  IFS=$ifs
}

# lsenv
#
#   Sorts and lists exported environment variables.
#
lsenv()
{
  env \
      | LC_ALL=C sort -t '=' -k 1 \
      | sed $'s/^/\033[1m/; s/=/=\033[0m/'
}

# cdn3 [<option>...] [<path>]
#
#   n3 wrapper activating cd on quit.
#
cdn3()
{
  local tmpfile excode
  tmpfile=$(mktemp /tmp/n3.XXXXX)
  NNN_TMPFILE=$tmpfile command n3 "$@"
  excode=$?
  [[ -f $tmpfile ]] && . "$tmpfile"
  rm -f "$tmpfile"
  return "$excode"
}

mksh()
{
  if [[ $# -ne 1 ]]; then
    gale_diag 'usage: mksh <file>'
    return 1
  fi
  gale_echo '#!/bin/sh' > "$1" \
    && chmod +x -- "$1"
}

# BANNER
# ==============================================================================

gale_echo $'\033[7m'"  Bash $BASH_VERSION on ${TERM:-unknown} | Powered by Gale  "$'\033[0m'

# PROMPT
# ==============================================================================

# if the last command exited unsuccessfully, show the exit code
gale_show_excode()
{
  local code="$?"
  local esc=$'\033'
  if [[ $code -gt 0 ]]; then
    if [[ $GALE_COLORS -ge 256 ]]; then
      gale_echo "$esc[0;38;5;203;48;5;88m exit $code $esc[0m"
    else
      gale_echo "$esc[0;31m[exit $code]$esc[0m"
    fi
  fi
}

# update the terminal title
gale_update_title()
{
  printf '\033]2;%s\003\\' "${USER}@${HOSTNAME%%.*} ${PWD/#$HOME/\~}"
}

PS1=
PS1+='\[\e[0;1m\]'

# autodetect nnn
if [[ $NNNLVL ]]; then
  if [[ $GALE_COLORS -ge 256 ]]; then
    PS1+='\[\e[37;45m\] nnn($NNNLVL) '
  else
    PS1+='\[\e[35m\]nnn($NNNLVL) '
  fi
fi

if [[ $GALE_COLORS -ge 256 ]]; then
  PS1+='\[\e[37;48;5;196m\] \u@\h '
  PS1+='\[\e[48;5;124m\] \w '
  PS1+='\[\e[22;38;5;203;48;5;88m\]\$\[\e[0m\] '
else
  PS1+='\[\e[31m\]\u@\h \[\e[34m\]\w \[\e[0m\]\$ '
fi

PROMPT_COMMAND=(gale_show_excode gale_update_title)

# KEYBINDINGS
# ==============================================================================

gale_readline_print_variable()
{
  set -- "${READLINE_LINE:0:$READLINE_POINT}"
  set -- "${1##*[!0-9A-Za-z_]}"
  if [[ $1 ]]; then
    if [[ -v $1 ]]; then
      gale_echo "$1=${!1@Q}"
    else
      gale_echo "$1 is unset"
    fi
  fi
}

bind -x '"\C-x\C-p": gale_readline_print_variable'

# LATE HOOK
# ==============================================================================

# If the local configuration defines a gale_late_hook, run it after everything
# else.
if declare -F gale_late_hook &>/dev/null; then
  gale_late_hook
  unset -f gale_late_hook
fi

# vim:ft=bash
