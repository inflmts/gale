#
# ~/.bashrc
#
# Distributed with corecon
# Author: Daniel Achelon
#

# quit unless interactive
# apparently needed for rcp or scp or something
[[ $- != *i* ]] && return

__ps1_exit_status() {
  local n="$?"
  [ "$n" -gt 0 ] && printf ' ?%s' "$n"
}

# build a custom prompt
printf -v PS1 %s \
  '\[\e[0;1;31m\]' \
  '\u@\h ' \
  '\[\e[34m\]' \
  '\w' \
  '\[\e[33m\]' \
  '$(__ps1_exit_status)' \
  '\[\e[0m\]' \
  ' \$ '

#
# ALIASES & FUNCTIONS
#

alias ccon='corecon'

alias ls='ls -hv --color=auto --group-directories-first'
alias lsa='ls -A'
alias ll='ls -l'
alias lla='ls -lA'

alias grep='grep --color=auto'
alias pacman='pacman --color=auto'
alias date='date +"%a %Y-%m-%d %I:%M %p"'
alias userctl='systemctl --user'

# list file systems
lsfs() {
  lsblk -o NAME,FSTYPE,LABEL,FSUSED,FSSIZE,FSUSE%
}

# list file systems (+UUID)
lsfsu() {
  lsblk -o NAME,FSTYPE,LABEL,UUID,FSUSED,FSSIZE,FSUSE%
}

# list gpt partitions
lsgpt() {
  lsblk -o NAME,PARTLABEL,PARTUUID
}

# list gpt file systems
lsgfs() {
  lsblk -o NAME,FSTYPE,LABEL,PARTLABEL,FSUSED,FSSIZE,FSUSE%
}

# cdnew <dir>
#
#   Create (recursively) and change to new directory <dir>.
#
cdnew() {
  if [ "$#" -eq 1 ]; then
    mkdir -p -- "$1" && cd -- "$1"
  else
    echo >&2 'usage: cdnew <dir>'
    return 1
  fi
}

# cdfzf
#
#   Change directory with fzf.
#
cdfzf() {
  if ! command -v fzf &>/dev/null; then
    echo >&2 "fzf not installed"
    return 1
  fi

  local shopt="$(shopt -p)"
  shopt -s nullglob
  # We don't use dotglob here because we want the dotfiles to appear *after* the
  # regular files. Except for .. , which should appear first.
  shopt -u dotglob
  while dir="$(
    for dir in .. * .[!.]* ..?*; do
      [ -d "$dir" ] && printf "%s\n" "$dir"
    done | fzf --prompt "$PWD/" --no-sort --no-clear
  )"; do
    cd "$dir"
  done
  tput rmcup
  eval "$shopt"
}

# udmount <device>
#
#   Mount <device> with udisksctl.
#
udmount() {
  if [ "$#" -eq 1 ]; then
    udisksctl mount -b "$1"
  else
    echo >&2 'usage: udmount <dev>'
    return 1
  fi
}

# udeject <device>
#
#   Unmount and power off <device> with udisksctl.
#
udeject() {
  if [ "$#" -eq 1 ]; then
    udisksctl unmount -b "$1" && udisksctl power-off -b "$1"
  else
    echo >&2 'usage: udeject <dev>'
    return 1
  fi
}

nvminit() {
  if [ -d ~/.nvm ]; then
    unset -f nvm nvminit
    export NVM_DIR="$HOME/.nvm"
    \. "$NVM_DIR/nvm.sh"
    \. "$NVM_DIR/bash_completion"
  else
    echo >&2 'error: nvm is not installed'
    return 1
  fi
}

nvm() {
  nvminit && nvm "$@"
}

# vim:ft=bash
