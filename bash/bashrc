#=============================================================================
# ~/.bashrc
#
# This file is part of Gale.
#
# Local changes should be made at:
#
#   ~/.config/gale/bashrc
#
#=============================================================================

# quit unless interactive
# apparently needed for rcp or scp or something
[[ $- != *i* ]] && return

GALE_ENABLE_BANNER=yes

# +H    disable history substitution with '!'
# -u    fail on undefined variable references
set +H -u

unset -f gale_late_hook
if [[ -f ~/.config/gale/bashrc ]]; then
  . ~/.config/gale/bashrc
fi

__gale_echo() { command printf '%s\n' "$1"; }
__gale_diag() { command printf >&2 '%s\n' "$1"; }
__gale_warn() { command printf >&2 'warning: %s\n' "$1"; }
__gale_err() { command printf >&2 'error: %s\n' "$1"; }

if [[ -z ${GALE_COLORS-} ]]; then
  # try to figure out number of colors based on $TERM
  case ${TERM-} in
    # these terms support no colors
    dumb) GALE_COLORS=0 ;;
    # these terms support 8 colors
    linux) GALE_COLORS=1 ;;
    # go out on a whim and assume 256 color support
    *) GALE_COLORS=2 ;;
  esac
fi

# setup colors for ls (and tree)
if __gale_dircolors=$(dircolors 2>/dev/null); then
  eval "$__gale_dircolors"
fi
unset __gale_dircolors

#=============================================================================
# FUNCTIONS & ALIASES
#=============================================================================

# __gale_spawn <command> [<args>...]
#
#   Fork a command using setsid(1).
#
__gale_spawn() {
  local path
  if ! path=$(type -P "$1") &>/dev/null; then
    __gale_err "command not found: $1"
    return 1
  fi
  shift
  setsid -f -- "$path" "$@" <&- &>/dev/null
}

alias grep='grep --color=auto'
alias md='mkdir -pv'

__gale_ls() {
  LC_COLLATE=C command ls -h --group-directories-first --color=auto "$@"
}

alias ls='__gale_ls'
alias lsa='__gale_ls -A'
alias ll='__gale_ls -l'
alias lla='__gale_ls -lA'

__gale_tree() {
  LC_COLLATE=C command tree --dirsfirst "$@"
}

alias tree='__gale_tree'
alias treea='__gale_tree -a'
alias treed='__gale_tree -d'
alias treeda='__gale_tree -da'

clock() {
  date +$'\n    %a %Y/%m/%d \033[1m%I:%M %p\033[0m %Z\n'
}

bind -x '"\C-t": clock'

# display the function's arguments
argv() {
  __gale_echo "$# argument(s):"
  if [[ $# -gt 0 ]]; then
    printf '%q\n' "$@"
  fi
}

# display the number of arguments
argc() {
  __gale_echo "$# argument(s)"
}

f() {
  if [[ $# -eq 0 ]]; then
    __gale_diag "f: expected command"
    return 1
  fi
  __gale_spawn "$@"
}

fx() {
  if [[ $# -eq 0 ]]; then
    __gale_diag "fx: expected command"
    return 1
  fi
  __gale_spawn "$@" && exit
}

## BLOCK DEVIES

# include file system information
lsfs() {
  command lsblk -o NAME,FSTYPE,LABEL,FSUSED,FSUSE%,FSSIZE,MOUNTPOINTS "$@"
}

# include GPT partition information
lsgpt() {
  command lsblk -o NAME,TYPE,RM,SIZE,PARTUUID,PARTLABEL "$@"
}

# cdnew <dir>
#
#   Create (recursively) and change to directory <dir>.
#
cdnew() {
  if [[ $# -eq 1 ]]; then
    mkdir -vp -- "$1" && cd -- "$1"
  else
    __gale_diag 'usage: cdnew <dir>'
    return 1
  fi
}

__gale_resolve_block_device() {
  case $1 in
    l=*)
      __gale_echo "/dev/disk/by-label/${1#*=}"
      ;;
    pl=*)
      __gale_echo "/dev/disk/by-partlabel/${1#*=}"
      ;;
    /*)
      __gale_echo "$1"
      ;;
    *)
      __gale_err "invalid block device: $1"
      return 1
      ;;
  esac
}

# udmount <source>
#
#   Mount <source> with udisksctl.
#
udmount() {
  local source
  if [[ $# -ne 1 ]]; then
    __gale_diag 'usage: udmount <source>'
    return 1
  fi
  source=$(__gale_resolve_block_device "$1") || return
  udisksctl mount -b "$source"
}

# udumount <source>
#
#   Unmount <source> with udisksctl.
#
udumount() {
  local source
  if [[ $# -ne 1 ]]; then
    __gale_diag 'usage: udeject <source>'
    return 1
  fi
  source=$(__gale_resolve_block_device "$1") || return
  udisksctl unmount -b "$source"
}

# lspath
#
#   List the contents of the $PATH environment variable.
#
lspath() {
  local -
  local ifs ent
  ifs=$IFS
  IFS=:
  set -f
  for ent in $PATH; do
    __gale_echo "${ent/#"$HOME"/\~}"
  done
  IFS=$ifs
}

# lsenv
#
#   Sorts and lists exported environment variables.
#
lsenv() {
  env \
      | LC_ALL=C sort -t '=' -k 1 \
      | sed $'s/^/\033[1m/; s/=/=\033[0m/'
}

# cdn3 [<option>...] [<path>]
#
#   n3 wrapper with cd on quit.
#
cdn3() {
  local tmpfile excode
  tmpfile=$(mktemp /tmp/n3.XXXXX)
  NNN_TMPFILE=$tmpfile command n3 "$@"
  excode=$?
  [[ -f $tmpfile ]] && . "$tmpfile"
  rm -f "$tmpfile"
  return "$excode"
}

__gale_mkscript_usage() {
  cat >&2 <<\END
usage: mkscript [options] <file> [<type>]

Creates an executable script. By default, mkscript creates a shell script.

Script types:
  sh      shell script
  bash    Bash script
  node    Node.js script
END
}

mkscript() {
  local target type template_file

  while [[ $# -gt 0 ]]; do
    case $1 in
      --)
        shift
        break
        ;;
      --help)
        __gale_mkscript_usage
        return 0
        ;;
      -*)
        __gale_diag "mkscript: invalid option: $1"
        return 1
        ;;
      *)
        break
        ;;
    esac
    shift
  done

  case $# in
    1) target=$1; type=sh ;;
    2) target=$1; type=$2 ;;
    *) __gale_mkscript_usage; return 1 ;;
  esac

  case $type in
    sh|bash|node)
      template_file="$HOME/.gale/mkscript-templates/$type"
      ;;
    *)
      __gale_diag "mkscript: invalid script type '$type'"
      return 1
      ;;
  esac

  if [[ -e "$target" ]]; then
    __gale_diag "mkscript: target exists: $target"
    return 1
  fi

  cp -- "$template_file" "$target" && chmod +x -- "$target"
}

# open files with xdg-open
open() {
  __gale_spawn xdg-open "$@"
}

# open firefox
ff() {
  __gale_spawn firefox "$@"
}

# open a new window in firefox
ffnw() {
  __gale_spawn firefox --new-window "$@"
}

#=============================================================================
# BANNER
#=============================================================================

# Disable with `GALE_ENABLE_BANNER=no`.

if [[ $GALE_ENABLE_BANNER = yes ]]; then
  __gale_echo $'\033[7m'"  Bash $BASH_VERSION on ${TERM:-unknown} | Powered by Gale  "$'\033[0m'
fi

#=============================================================================
# PROMPT
#=============================================================================

# if the last command exited unsuccessfully, show the exit code
__gale_show_excode() {
  local code="$?"
  local esc=$'\033'
  if [[ $code -gt 0 ]]; then
    if [[ $GALE_COLORS -ge 2 ]]; then
      __gale_echo "$esc[0;38;5;203;48;5;88m exit $code $esc[0m"
    else
      __gale_echo "$esc[0;31m[exit $code]$esc[0m"
    fi
  fi
}

# update the terminal title
__gale_update_title() {
  printf '\033]2;%s\007' "${USER}@${HOSTNAME%%.*} ${PWD/#$HOME/\~}"
}

PS1=
PS1+='\[\e[0;1m\]'

# autodetect nnn
if [[ ${NNNLVL-} ]]; then
  if [[ $GALE_COLORS -ge 2 ]]; then
    PS1+='\[\e[37;45m\] nnn($NNNLVL) '
  else
    PS1+='\[\e[35m\]nnn($NNNLVL) '
  fi
fi

if [[ $GALE_COLORS -ge 2 ]]; then
  PS1+='\[\e[37;48;5;196m\] \u@\h '
  PS1+='\[\e[48;5;124m\] \w '
  PS1+='\[\e[22;38;5;203;48;5;88m\]\$\[\e[0m\] '
else
  PS1+='\[\e[31m\]\u@\h \[\e[34m\]\w \[\e[0m\]\$ '
fi

PROMPT_COMMAND=(__gale_show_excode __gale_update_title)

#=============================================================================
# KEYBINDINGS
#=============================================================================

__gale_readline_print_variable() {
  set -- "${READLINE_LINE:0:$READLINE_POINT}"
  set -- "${1##*[!0-9A-Za-z_]}"
  if [[ $1 ]]; then
    if [[ -v $1 ]]; then
      __gale_echo "$1=${!1@Q}"
    else
      __gale_echo "$1 is unset"
    fi
  fi
}

bind -x '"\C-x\C-p": __gale_readline_print_variable'

#=============================================================================
# LATE HOOK
#=============================================================================

# If the local configuration defines a gale_late_hook, run it after everything
# else.
if declare -F gale_late_hook &>/dev/null; then
  gale_late_hook
fi

# vim:ft=bash
