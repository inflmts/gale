#!/bin/sh
# gale configuration utility
#
# This file is part of Gale.
#
# A simple grep-based utility for accessing and manipulating Gale's
# configuration system.
#
# The Gale configuration file is located at `.config/gale/config`.
#
# The configuration file consists of lines of the following format:
#
#   <key> '=' <value>
#
# Keys may contain any character in the set [0-9a-z.-] and may not begin with
# '.' or '-'. Values may contain any character except newline.
#
# Requirements:
#   - grep -E -m
#   - sed -E
#

echo() { printf '%s\n' "$1"; }
diag() { printf >&2 '%s\n' "$1"; }
warn() { printf >&2 'warning: %s\n' "$1"; }
err() { printf >&2 'error: %s\n' "$1"; }

usage()
{
  cat <<EOF
usage: galconf [<command> [<argument>...]]
commands:
  -h, --help
  -l, --list
  -s, --set <key>=<value>...
  -u, --unset <key>...
  -t, --test <key>...
  -g, --get [--chain] [--default=<value>] <key>...
      --wipe
options:
      --debug           show debugging output
EOF
}

_NL='
'

# config directory
config_dir=~/.config/gale
# config file
config_file="$config_dir/config"

unset HELP MODE DEBUG DEFAULT
MODE=set

while [ "$#" -gt 0 ]; do
  case $1 in
    --)
      shift
      break
      ;;
    -[!-][!-]*)
      rest=${1#-?}
      set -- "${1%"$rest"}" "-$rest" "$@"
      ;;
    -h|--help)
      HELP=1
      ;;
    -l|--list)
      MODE=list
      ;;
    -s|--set)
      MODE=set
      ;;
    -u|--unset)
      MODE=unset
      ;;
    -t|--test)
      MODE=test
      ;;
    -g|--get)
      MODE=get
      ;;
    --default=*)
      DEFAULT=${1#*=}
      ;;
    --bool)
      DEFAULT=${DEFAULT-no}
      ;;
    --wipe)
      MODE=wipe
      ;;
    --debug)
      DEBUG=1
      ;;
    -*)
      err "invalid option: $1"
      exit 1
      ;;
    *)
      break
      ;;
  esac
  shift
done

if [ "$HELP" ]; then
  usage
  exit 0
fi

if [ "$DEBUG" ]; then
  debug() { printf >&2 '%s\n' "$1"; }
else
  debug() { :; }
fi

contains()
{
  case $1 in
    *"$2"*) return 0 ;;
    *) return 1 ;;
  esac
}

is_valid_key()
{
  case $1 in
    *[!0-9a-z.-]*) return 1 ;;
    [0-9a-z]*) return 0 ;;
    *) return 1 ;;
  esac
}

validate_keys()
{
  local key
  for key; do
    if ! is_valid_key "$key"; then
      err "invalid key: $key"
      exit 1
    fi
  done
}

validate_set_arguments()
{
  local arg
  for arg; do
    if ! contains "$arg" '='; then
      err "no value in argument: $arg"
      exit 1
    fi
    if ! is_valid_key "${arg%%=*}"; then
      err "invalid key in argument: $arg"
      exit 1
    fi
    if contains "$arg" "$_NL"; then
      err "invalid argument: $arg"
      exit 1
    fi
  done
}

func_list()
{
  if [ "$#" -gt 0 ]; then
    err "too many arguments"
    exit 1
  fi

  # very simple config pretty-printer
  if [ -e "$config_file" ]; then
    if command -v column >/dev/null 2>&1; then
      column --table -s '=' -l 2 --table-columns KEY,VALUE "$config_file"
    else
      cat "$config_file"
    fi
  fi
}

func_set()
{
  # quit if no arguments given
  [ "$#" -gt 0 ] || exit 0
  validate_set_arguments "$@"

  mkdir -p "$config_dir" || exit

  { # edit existing configuration if applicable
    if [ -s "$config_file" ]; then
      pattern=$(printf '%s\n' "$@" | sed -E 's/=.*$/=.*/')
      debug "pattern: $pattern"

      # pick existing entries that DON'T match the keys to be modified
      grep -Exv "$pattern" "$config_file"
    fi

    # add new entries
    printf '%s\n' "$@"
  } > "$config_file.new" || exit

  mv "$config_file.new" "$config_file"
}

func_unset()
{
  # only proceed if arguments are present
  # and the config file has keys to delete
  [ "$#" -gt 0 ] || exit 0
  validate_keys "$@"
  [ -s "$config_file" ] || exit 0

  pattern=$(printf '%s\n' "$@" | sed -E 's/$/=.*/')
  debug "pattern: $pattern"

  mkdir -p "$config_dir" || exit

  # pick existing entries that don't match keys provided in the command line
  grep -Exv "$pattern" "$config_file" > "$config_file.new"
  mv "$config_file.new" "$config_file"
}

func_test()
{
  # only proceed if arguments are present
  # and the config file has keys in the first place
  [ "$#" -gt 0 ] || exit 1
  validate_keys "$@"
  [ -s "$config_file" ] || exit 2

  pattern=$(printf '%s\n' "$@" | sed -E 's/$/=.*/')
  debug "pattern: $pattern"

  grep -Exq "$pattern" "$config_file" || exit 2
}

try_grep()
{
  local match
  debug "trying grep -Exm1 $1"
  if match=$(grep -Exm1 "$1" "$config_file"); then
    echo "${match#*=}"
    exit 0
  fi
}

func_get()
{
  # only proceed if arguments are present
  # and the config file has keys in the first place
  if [ "$#" -eq 0 ]; then
    err "get requires arguments"
    exit 1
  fi
  validate_keys "$@"
  if [ -s "$config_file" ]; then
    if [ "$chain" ]; then
      for key; do
        try_grep "${key}=.*"
      done
    else
      pattern="$1=.*"
      shift
      for key; do
        pattern="${pattern}${_NL}$1=.*"
      done
      try_grep "$pattern"
    fi
  fi
  if [ "${DEFAULT+1}" ]; then
    echo "$DEFAULT"
    exit 0
  fi
  exit 2
}

func_wipe()
{
  if [ "$#" -gt 0 ]; then
    err "too many arguments"
    exit 1
  fi

  # doesn't actually destroy, only moves to $config_file.old
  if [ -e "$config_file" ]; then
    mv "$config_file" "$config_file.old"
  fi
}

case "$MODE" in
  list)   func_list   "$@" ;;
  set)    func_set    "$@" ;;
  unset)  func_unset  "$@" ;;
  test)   func_test   "$@" ;;
  get)    func_get    "$@" ;;
  wipe)   func_wipe   "$@" ;;
esac
