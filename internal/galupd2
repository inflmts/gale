#!/usr/bin/env bash
# gale build system (v2)
#
# Requirements:
#   - bash
#
# FIXME: This is a work in progress!
#

shopt -s nullglob
set -f -o pipefail
cd ~

progname=galupd
echo() { printf '%s\n' "$1"; }
diag() { printf >&2 '%s\n' "$1"; }
quit() { printf >&2 '%s\n' "$2"; exit "$1"; }

usage()
{
  cat <<END
usage: $progname [<option>...] [<target>...]
END
}

while [[ $# -gt 0 ]]; do
  case $1 in
    --)
      shift
      break
      ;;
    --help)
      usage
      exit 0
      ;;
    -*)
      quit 1 "$progname: invalid option: $1"
      ;;
    *)
      break
      ;;
  esac
  shift
done

# DEPENDENCIES
#
#    source
#   _/  |
#  /    v
#  | target/virtual
#  |    |
#  v    v
# declarator
#

getline() { IFS= read -r "$1"; }
setvar() { printf -v "$1" %s "$2"; }
getvar() { R=${!1}; }

# create_node <type> <status>
#
#   Create a node and returns its id.
#
create_node()
{
  local type="$1" status="$2"
  local id
  id=$(( node_count++ ))
  set_node_type "$id" "$type"
  set_node_status "$id" "$status"
  R=$id
}

get_node_type() { getvar "node$1_typ"; }
get_node_status() { getvar "node$1_sta"; }
set_node_status() { setvar "node$1_sta" "$2"; }

get_source_file() { getvar "node$1_fil"; }
set_source_file() { setvar "node$1_src" "$2"; }
get_source_sig() { getvar "node$1_sig"; }
set_source_sig() { setvar "node$1_sig" "$2"; }

get_target_command() { getvar "node$1_cmd"; }
set_target_command() { setvar "node$1_cmd" "$2"; }
get_target_dirty() { getvar "node$1_drt"; }
set_target_dirty() { setvar "node$1_drt" "$2"; }
get_target_output_count() { getvar "node$1_onr"; }
set_target_output_count() { setvar "node$1_onr" "$2"; }
get_target_output() { getvar "node$1_o$2"; }
set_target_output() { setvar "node$1_o$2" "$3"; }
get_target_input_count() { getvar "node$1_inr"; }
set_target_input_count() { setvar "node$1_inr" "$2"; }
get_target_input() { getvar "node$1_i$2"; }
set_target_input() { setvar "node$1_i$2" "$3"; }

get_decl_input() { getvar "node$1_inp"; }
set_decl_input() { setvar "node$1_inp" "$2"; }

# read_database
#
#   Read database from stdin.
#
# For source nodes:
#
#   "@source" or "@optsrc"
#   node id
#   source name
#   source signature
#
# For target nodes:
#
#   "@target" or "@virtual"
#   node id
#   rule id
#   target name
#
# For rules:
#
#   "@rule"
#   rule id
#   command
#   dirty flag
#   zero or more input ids, terminated by empty line
#
read_database()
{
  # FIXME: declarations

  while IFS=: read -r ; do
    case $line in
      @source)
      local id name sig
      if ! { getline id && getline name && getline sig; }; then
        err="unexpected end of file"
        return 2
      fi
      set_node_type "$id" SOURCE
      assoc_node_name "$id" "$name"
      set_source_sig "$id" "$sig"
      ;;

    @target)
      local id rule name
      if ! { getline id && getline rule && getline name; }; then
        err="unexpected end of file"
        return 2
      fi
      set_node_type "$id" TARGET
      assoc_node_name "$id" "$name"
      assoc_target_rule "$id" "$rule"
      ;;

    @rule)
      local id command dirty
      if ! { getline id && getline command && getline dirty; }; then
        err="unexpected end of file"
        return 2
      fi
      set_rule_command "$id" "$command"
      set_rule_dirty "$id" "$dirty"

      icount=0
      while getline input; do
        [[ -z $input ]] && break
        set_rule_input "$id" "$(( icount++ ))" "$input"
      done
      set_rule_input_count "$id" "$icount"
      ;;

    *)
      err="expected directive"
      return 2
      ;;

  esac; done

  if [[ $# -gt 0 ]]; then
    err="unterminated @decl"
    return 2
  fi
  return 0
}

# write_database
#
#   Write database to stdout.
#
write_database()
{
  return 1
}

# read_manifest
#
#   Read manifest from stdin. This may only be called once.
#
read_manifest()
{
  local line
  while getline line; do
    case $line in
      ''|'#'*) continue ;;
      '[rule]') _read_rule || return ;;
      *)
        err="invalid directive: $line"
        return 2
        ;;
    esac
  done
}

# update_decls
#
#   Update all declarators.
#
update_decls()
{
  local i decl status input itype ifile ccount cid ctype
  set -- "$root_decl_id"
  while [[ $# -gt 0 ]]; do
    decl=$1
    shift
    get_node_status "$decl"; status="$R"
    if [[ $status = done ]]; then
      continue
    fi
    get_decl_input "$decl"; input=$R
    get_node_type "$input"; itype=$R
    case $itype in
      source) update_source "$input" ;;
      target) update_target "$input" ;;
      *) quit 2 "$progname: declarator $decl: input $input is $itype" ;;
    esac
    if is_node_dirty "$decl"; then
      get_node_file "$input"; ifile=$R
      load_declarator "$decl" < "$ifile"
    fi
    get_decl_child_count "$did"; ccount=$R
    for (( i = 0; i < ccount; i++)); do
      get_decl_child "$did" "$i"; cid=$R
      get_node_type "$cid"; ctype=$R
      if [[ $ctype = decl ]]; then
        set -- "$@" "$cid"
      fi
    done
  done
}

_request_nodes()
{
  local id status type input
  while [[ $# -gt 0 ]]; do
    id=$1
    shift
    get_node_status "$id"; status=$R
    case $status in
      REQUESTED|DONE|FAILED) continue ;;
      UNKNOWN) err="no such node: $id"; return 1 ;;
      STANDBY) ;;
      REQUESTING) err="circular dependency: $id"; return 1 ;;
      *) err="request_node: $id has status $status"; return 1 ;;
    esac
    get_node_type "$id"; type=$R
    if [[ $type = SOURCE ]]; then
      requested_sources+=("$id")
    else
      set_node_status "$id" REQUESTING
      get_target_input_count "$id"; icount=$R
      for (( i = 0; i < icount; i++ )); do
        get_target_input "$id" "$i"; iid=$R
        request_node "$iid"
      done
      set_node_status "$id" REQUESTED
      requested_targets+=("$id")
    fi
    set_node_status "$id" REQUESTED
  done
}

_soft_request_nodes()
{
  local id status type input
  while [[ $# -gt 0 ]]; do
    id=$1
    shift
    get_node_status "$id"; status=$R
    case $status in
      REQUESTED|DONE|FAILED) continue ;;
      UNKNOWN|STANDBY) ;;
      *) err="soft_request_nodes: $id has status $status"; return 1 ;;
    esac
    get_node_type "$id"; type=$R
    if [[ $type = SOURCE ]]; then
      requested_sources+=("$id")
      set_node_status "$id" "${status}-REQUESTED"
    else
      get_node_inputs "$id"; inputs=$R
      set -- $inputs "$@"
    fi
  done
}

update_nodes()
{
  local id file old_sig new_sig i dcount did
  for id; do
    request_node "$id"
  done

  while IFS=: read -r sig name; do
    get_source_sig "$name"; old_sig=$R
    if [[ "$old_sig" != "$sig" ]]; then
      set_node_status "$name" DONE
    fi
    set_source_sig "$name" "$sig"
  done < <(stat -c '%s.%Y.%i:%n:' -- "${requested_sources[@]}")

  for name in "${requested_sources[@]}"; do
    get_node_status "$name"; status=$R
    if [[ $status = REQUESTED ]]; then
      set_node_status "$name" FAILED
    fi
  done

  local id status
  for id in "${requested_targets[@]}"; do
    get_node_status "$id"; status=$R
    if is_node_dirty "$id"; then
      if [[ $status = DONE ]]; then
        propagate "$id" 1
        return
      fi
      get_target_command "$id"; command=$R
      if run_command "$command"; then
        propagate "$id" 0
      else
        propagate "$id" 1
      fi
    fi
    set_node_status "$id" DONE
  done
}

quit 69 "$progname: not implemented"

if [[ -e .data/gale/galupd.db ]]; then
  read_database < .data/gale/galupd.db
fi
update_declarators
update "$@"
if ! mkdir -p .data/gale; then
  quit 2 "$progname: unable to create database directory .data/gale"
fi
write_database > .data/gale/galupd.db.new
mv -T .data/gale/galupd.db.new .data/gale/galupd.db

# END
