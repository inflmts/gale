# ~/.bashrc
#
# This file is part of Gale.
#
# Bash shell initialization file.

# quit unless interactive
# apparently needed for rcp or scp or something
[[ $- != *i* ]] && return

# this allows us to get away (mostly) with $var instead of "$var"
IFS=

# Whether to use fancy colors.
# This requires at least 256-color support from the terminal.
GALE_FANCY=
[[ $(tput colors 2> /dev/null) -ge 256 ]] \
  && GALE_FANCY=1

# FUNCTIONS & ALIASES
# ==============================================================================

alias ls='ls -hv --color=auto --group-directories-first'
alias lsa='ls -A'
alias ll='ls -l'
alias lla='ls -lA'

alias grep='grep --color=auto'
alias pacman='pacman --color=auto'
#alias date='date +"%a %Y-%m-%d %I:%M %p"'

alias sysleep='systemctl suspend'
alias userctl='systemctl --user'

# display the arguments
argv() {
  local arg
  printf '%s arguments:\n' "$#"
  for arg; do
    printf '> %s\n' "${arg@Q}"
  done
}

# list file systems
lsfs() {
  lsblk -o NAME,FSTYPE,LABEL,FSUSED,FSSIZE,FSUSE%
}

# list file systems (+UUID)
lsfsu() {
  lsblk -o NAME,FSTYPE,LABEL,UUID,FSUSED,FSSIZE,FSUSE%
}

# list gpt partitions
lsgpt() {
  lsblk -o NAME,PARTLABEL,PARTUUID
}

# list gpt file systems
lsgfs() {
  lsblk -o NAME,FSTYPE,LABEL,PARTLABEL,FSUSED,FSSIZE,FSUSE%
}

# cdnew <dir>
#
#   Create (recursively) and change to directory <dir>.
#
cdnew() {
  if [[ $# -eq 1 ]]; then
    mkdir -vp -- "$1" && cd -- "$1"
  else
    echo >&2 'usage: cdnew <dir>'
    return 1
  fi
}

_resolve_source() {
  case $1 in
    LABEL=*)
      _DEVICE="/dev/disk/by-label/${1#LABEL=}" ;;
    PARTLABEL=*)
      _DEVICE="/dev/disk/by-partlabel/${1#PARTLABEL=}" ;;
    /*)
      _DEVICE="$1" ;;
    *)
      _DEVICE="/dev/$1" ;;
  esac
}

# udmount <source>
#
#   Mount <source> with udisksctl.
#
udmount() {
  if [[ $# -ne 1 ]]; then
    echo >&2 'usage: udmount <source>'
    return 1
  fi
  _resolve_source "$1"
  udisksctl mount -b "$_DEVICE"
}

# udeject <source>
#
#   Unmount and power off <source> with udisksctl.
#
udeject() {
  if [[ $# -ne 1 ]]; then
    echo >&2 'usage: udeject <source>'
    return 1
  fi
  _resolve_source "$1"
  udisksctl unmount -b "$_DEVICE" && udisksctl power-off -b "$_DEVICE"
}

# daemonize (fork) a command
f() { setsid -f -- "$@" &> /dev/null; }
# daemonize (fork) a command and exit
fx() { f "$@" && exit; }

# lspath
#
#   List the contents of the $PATH environment variable.
#
lspath() {
  local -
  local ifs ent
  ifs=$IFS
  IFS=:
  set -f
  for ent in $PATH; do
    printf '%s\n' "${ent/#"$HOME"/\~}"
  done
  IFS=$ifs
}

# lsenv
#
#   Sorts and prints exported environment variables.
#
lsenv() {
  local sed_script
  if [[ $GALE_FANCY ]]; then
    sed_script=$'s/^/\033[38;5;245m/; s/=/=\033[0m/'
  else
    sed_script=$'s/^/\033[1m/; s/=/=\033[0m/'
  fi
  env \
    | LC_ALL=C sort -t '=' -k 1 \
    | sed "$sed_script"
}

# n3 [<option>...] [<path>]
#
#   n3 wrapper enabling cd on quit.
#
n3() {
  local tmpfile excode
  tmpfile=$(mktemp /tmp/n3.XXXXX)
  NNN_TMPFILE=$tmpfile command n3 "$@"
  excode=$?
  [[ -f "$tmpfile" ]] && . "$tmpfile"
  rm -f "$tmpfile"
  return "$excode"
}

# INITIALIZATION
# ==============================================================================

GALE_FEATURES=
GALE_ENABLE_NVM=

# source local configuration from $XDG_CONFIG_HOME/gale/bashrc
gale_local_config="${XDG_CONFIG_HOME:-$HOME/.config}/gale/bashrc"
[[ -s $gale_local_config ]] && . "$gale_local_config"

# initialize nvm if installed
if [[ $GALE_ENABLE_NVM ]] && [[ -d ~/.nvm ]]; then
  GALE_FEATURES+=' +nvm'
  export NVM_DIR="$HOME/.nvm"
  source "$NVM_DIR/nvm.sh" --no-use
  source "$NVM_DIR/bash_completion"
fi

# BANNER
# ==============================================================================

printf '\033[0;7m  Bash %s | Powered by Gale  \033[0m\n' "$BASH_VERSION"
if [[ $GALE_FANCY ]]; then
  printf '\033[38;5;248mSystem:\033[0m %s\n' "$(uname -srm)"
  printf '\033[38;5;248mTerminal:\033[0m %s \033[38;5;248m(fancy)\033[0m\n' "${TERM:-unknown}"
else
  printf 'System: %s\n' "$(uname -srm)"
  printf 'Terminal: %s\n' "${TERM:-unknown}"
fi

# PROMPT
# ==============================================================================

# if the last command exited unsuccessfully, show the exit code
gale_show_excode() {
  local excode="$?"
  if [[ $excode -gt 0 ]]; then
    if [[ $GALE_FANCY ]]; then
      printf >&2 '\e[0;38;5;203;48;5;88m exit %s \e[0m\n' "$excode"
    else
      printf >&2 '\e[0;31m[exit %s]\e[0m\n' "$excode"
    fi
  fi
}

# update the terminal title
gale_update_title() {
  printf '\033]2;%s\007' "${USER}@${HOSTNAME%%.*} ${PWD/#$HOME/\~}"
}

PS1=
PS1+='\[\e[0;1m\]'

# autodetect nnn
if [[ $NNNLVL ]]; then
  if [[ $GALE_FANCY ]]; then
    PS1+='\[\e[37;45m\] nnn($NNNLVL) '
  else
    PS1+='\[\e[35m\]nnn($NNNLVL) '
  fi
fi

if [[ $GALE_FANCY ]]; then
  PS1+='\[\e[37;48;5;196m\] \u@\h '
  PS1+='\[\e[48;5;124m\] \w '
  PS1+='\[\e[22;38;5;203;48;5;88m\]\$\[\e[0m\] '
else
  PS1+='\[\e[31m\]\u@\h \[\e[34m\]\w \[\e[0m\]\$ '
fi

PROMPT_COMMAND=(gale_show_excode gale_update_title)

# vim:ft=bash
