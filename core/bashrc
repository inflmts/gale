# ~/.bashrc
#
# This file is part of Gale.
#
# Bash shell initialization file.
#

# quit unless interactive
# apparently needed for rcp or scp or something
[[ $- != *i* ]] && return

gale_echo() { command printf '%s\n' "$1"; }
gale_diag() { command printf >&2 '%s\n' "$1"; }

# Setting this to a non-empty value turns on 256-color support in Gale.
# If left unset, this will be automatically detected using tput.
unset GALE_FANCY

# FUNCTIONS & ALIASES
# ==============================================================================

alias ls='ls -hv --color=auto --group-directories-first'
alias lsa='ls -A'
alias ll='ls -l'
alias lla='ls -lA'
alias tree='tree -v --dirsfirst'

alias grep='grep --color=auto'
alias pacman='pacman --color=auto'
#alias date='date +"%a %Y-%m-%d %I:%M %p"'

alias sysleep='systemctl suspend'
alias userctl='systemctl --user'

# display the function's arguments
argv() {
  gale_echo "$# argument(s):"
  if [[ $# -gt 0 ]]; then
    printf '%q\n' "$@"
  fi
}

# BLOCK DEVICES

lsblk() {
  command lsblk -o NAME,TYPE,RM,SIZE,RO,MOUNTPOINTS "$@"
}

# list file systems
lsfs() {
  command lsblk -o NAME,FSTYPE,LABEL,FSUSED,FSUSE%,FSSIZE,MOUNTPOINTS "$@"
}

# cdnew <dir>
#
#   Create (recursively) and change to directory <dir>.
#
cdnew() {
  if [[ $# -eq 1 ]]; then
    mkdir -vp -- "$1" && cd -- "$1"
  else
    gale_diag 'usage: cdnew <dir>'
    return 1
  fi
}

_resolve_source() {
  case $1 in
    LABEL=*)
      _DEVICE="/dev/disk/by-label/${1#LABEL=}" ;;
    PARTLABEL=*)
      _DEVICE="/dev/disk/by-partlabel/${1#PARTLABEL=}" ;;
    /*)
      _DEVICE="$1" ;;
    *)
      _DEVICE="/dev/$1" ;;
  esac
}

# udmount <source>
#
#   Mount <source> with udisksctl.
#
udmount() {
  if [[ $# -ne 1 ]]; then
    gale_diag 'usage: udmount <source>'
    return 1
  fi
  _resolve_source "$1"
  udisksctl mount -b "$_DEVICE"
}

# udumount <source>
#
#   Unmount <source> with udisksctl.
#
udumount() {
  if [[ $# -ne 1 ]]; then
    gale_diag 'usage: udeject <source>'
    return 1
  fi
  _resolve_source "$1"
  udisksctl unmount -b "$_DEVICE"
}

# daemonize (fork) a command
f() { setsid -f -- "$@" &> /dev/null; }
# daemonize (fork) a command and exit
fx() { f "$@" && exit; }

# lspath
#
#   List the contents of the $PATH environment variable.
#
lspath() {
  local -
  local ifs ent
  ifs=$IFS
  IFS=:
  set -f
  for ent in $PATH; do
    gale_echo "${ent/#"$HOME"/\~}"
  done
  IFS=$ifs
}

# lsenv
#
#   Sorts and lists exported environment variables.
#
lsenv() {
  env \
    | LC_ALL=C sort -t '=' -k 1 \
    | sed $'s/^/\033[1m/; s/=/=\033[0m/'
}

# cdn3 [<option>...] [<path>]
#
#   n3 wrapper activating cd on quit.
#
cdn3() {
  local tmpfile excode
  tmpfile=$(mktemp /tmp/n3.XXXXX)
  NNN_TMPFILE=$tmpfile command n3 "$@"
  excode=$?
  [[ -f "$tmpfile" ]] && . "$tmpfile"
  rm -f "$tmpfile"
  return "$excode"
}

# INITIALIZATION
# ==============================================================================

# source local configuration from ~/.config/gale/bashrc
if [[ -s ~/.config/gale/bashrc ]]; then
  . ~/.config/gale/bashrc
fi

# if $GALE_FANCY wasn't set in configuration, autodetect using tput
if [[ -z "${GALE_FANCY+1}" ]]; then
  if [[ "$(tput colors 2> /dev/null)" -ge 256 ]]; then
    GALE_FANCY=1
  else
    GALE_FANCY=
  fi
fi

# PROMPT
# ==============================================================================

# if the last command exited unsuccessfully, show the exit code
gale_show_excode() {
  local excode="$?"
  if [[ $excode -gt 0 ]]; then
    if [[ $GALE_FANCY ]]; then
      printf >&2 '\e[0;38;5;203;48;5;88m exit %s \e[0m\n' "$excode"
    else
      printf >&2 '\e[0;31m[exit %s]\e[0m\n' "$excode"
    fi
  fi
}

# update the terminal title
gale_update_title() {
  printf '\033]2;%s\007' "${USER}@${HOSTNAME%%.*} ${PWD/#$HOME/\~}"
}

PS1=
PS1+='\[\e[0;1m\]'

# autodetect nnn
if [[ $NNNLVL ]]; then
  if [[ $GALE_FANCY ]]; then
    PS1+='\[\e[37;45m\] nnn($NNNLVL) '
  else
    PS1+='\[\e[35m\]nnn($NNNLVL) '
  fi
fi

if [[ $GALE_FANCY ]]; then
  PS1+='\[\e[37;48;5;196m\] \u@\h '
  PS1+='\[\e[48;5;124m\] \w '
  PS1+='\[\e[22;38;5;203;48;5;88m\]\$\[\e[0m\] '
else
  PS1+='\[\e[31m\]\u@\h \[\e[34m\]\w \[\e[0m\]\$ '
fi

PROMPT_COMMAND=(gale_show_excode gale_update_title)

# vim:ft=bash
