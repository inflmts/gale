#!/bin/sh
# simple pidfile utility
#
# This file is part of Gale.
#

echo() { printf '%s\n' "$1"; }
diag() { printf >&2 '%s\n' "$1"; }

usage() {
  cat <<EOF
usage: stupid --file=<file>
  --status [--quiet]
  --start <command> [<arg>...]
  --restart <command> [<arg>...]
  --restart-running <command> [<arg>...]
  --toggle <command> [<arg>...]
  --quit
EOF
}

pidfile=
oper=
quiet=
while [ "$#" -gt 0 ]; do
  case $1 in
    --file=*)
      pidfile=${1#*=}
      ;;
    --status)
      oper=status
      ;;
    --start)
      oper=start
      ;;
    --restart)
      oper=restart
      ;;
    --restart-running)
      oper=restart-running
      ;;
    --toggle)
      oper=toggle
      ;;
    --quit)
      oper=quit
      ;;
    --quiet)
      quiet=1
      ;;
    --)
      shift
      break
      ;;
    -*)
      usage
      exit 1
      ;;
    *)
      break
      ;;
  esac
  shift
done

# ensure an operation was provided on the command line
if [ -z "$oper" ]; then
  diag "no operation specified"
  exit 1
fi

# ensure a pidfile was provided on the command line
if [ -z "$pidfile" ]; then
  diag "no pidfile specified"
  exit 1
fi

# return successfully if the pidfile exists
# and the program it references is still running
_status() {
  local pid
  if pid=$(cat "$pidfile" 2>/dev/null) \
    && kill -s 0 -- "$pid" >/dev/null 2>&1
  then
    [ "$quiet" ] || echo "running on pid $pid"
    exit 0
  else
    [ "$quiet" ] || echo 'not running'
    exit 1
  fi
}

# attempt to lock the pidfile and start the program
_start() {
  # Using the -C option (hopefully) ensures
  # the command fails if the pidfile exists
  # or creates the pidfile if it doesn't.
  (set -C; : > "$pidfile") >/dev/null 2>&1 || return 1
  ( trap '' HUP
    trap 'kill "$pid"' INT QUIT TERM
    command "$@" & pid=$!
    echo "$pid" >> "$pidfile"
    wait "$pid"
    rm -f -- "$pidfile"
  ) <&- >/dev/null 2>&1 &
  return 0
}

# try a couple of times to start the program
_restart() {
  local try=0
  # TODO: configurable attempts?
  #       'sleep' between tries?
  while [ "$((try = try + 1))" -le 5 ]; do
    _start "$@" && return 0
  done
  diag "unable to restart program"
  return 1
}

# attempt to kill the program with the pid in the pidfile
# return successfully if the program was found and killed
_quit() {
  local pid
  pid=$(cat "$pidfile" 2>/dev/null) \
    && kill -- "$pid" >/dev/null 2>&1
}

case "$oper" in
  status)
    _status
    ;;
  start)
    _start "$@"
    ;;
  restart)
    if _quit
    then _restart "$@"
    else _start "$@"
    fi
    ;;
  restart-running)
    _quit && _restart "$@"
    ;;
  toggle)
    _quit || _start "$@"
    ;;
  quit)
    _quit
    ;;
esac
