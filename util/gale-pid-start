#!/bin/sh
# gale-pid-start - run a program with a pidfile
#
# This file is part of Gale.
#

set -u

echo() { printf '%s\n' "$1"; }
diag() { printf >&2 '%s\n' "$1"; }
warn() { printf >&2 'warning: %s\n' "$1"; }
err() { printf >&2 'error: %s\n' "$1"; }

usage() {
  cat >&2 <<EOF
usage: gale-pid-start [<options>...] <pidfile> <command> [<args>...]
options:
  --try         if the pidfile exists, don't consider this an error
  --help        show this help
EOF
}

try=

while [ $# -gt 0 ]; do
  case $1 in
    --)
      shift
      break
      ;;
    --try)
      try=1
      ;;
    --help)
      usage
      exit 0
      ;;
    -*)
      err "invalid option: $1"
      exit 1
      ;;
    *)
      break
      ;;
  esac
  shift
done

if [ $# -lt 2 ]; then
  err "not enough arguments"
  exit 1
fi

if ! (set -C && : > "$1") >/dev/null 2>&1; then
  if [ "$try" ]; then
    exit 0
  fi
  err "failed to lock pidfile '$1'"
  exit 1
fi

# This wrapper script will remove the pidfile when the command exits. We make
# sure to close stdin when executing the command to avoid accidentally consuming
# shell commands.
#
# The wrapper script ignores SIGHUP. If the wrapper script receives a kill
# signal, it will attempt to terminate the child process. In addition, if the
# wrapper script receives SIGUSR1, it will terminate and restart the child
# process.

setsid -f sh -s "$@" >/dev/null 2>&1 <<\ENDSCRIPT
pidfile=$1
shift
trap '' HUP
trap 'kill "$pid"' INT QUIT PIPE TERM USR2
trap 'restart=1; kill "$pid"' USR1
restart=1
while [ "$restart" ]; do
  restart=
  command "$@" <&- & pid=$!
  echo "$$ $pid" > "$pidfile"
  wait "$pid"
done
rm -f -- "$pidfile"
ENDSCRIPT
