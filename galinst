#!/bin/sh
# Gale installer

set -u

echo() { printf '%s\n' "$*"; }
msg() { printf >&2 '%s\n' "$*"; }
warn() { printf >&2 'warning: %s\n' "$*"; }
err() { printf >&2 'error: %s\n' "$*"; }

usage() {
  cat >&2 <<EOF
usage: galinst [<options>...]

Install Gale.

Options:
  -n, --dry-run   don't do anything, only show what would happen
  -v, --verbose   show skipped files as well
  -h, --help      show this help
EOF
}

dryrun=
verbose=

while [ $# -gt 0 ]; do
  case $1 in
    -[!-]?*)
      rest=${1#-?}
      cur=${1%"$rest"}
      shift
      set -- "$cur" "-$rest" "$@"
      continue
      ;;
    -n|--dry-run)
      dryrun=1
      ;;
    -v|--verbose)
      verbose=1
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      err "invalid option: $1"
      msg "Run 'galinst --help' for more information."
      exit 1
      ;;
  esac
  shift
done

# everything is relative to the home directory
cd || exit 1

gale_profile_file=".config/gale/profile"
gale_log_file=".data/gale/galinst.log"

gale_log_paths=
gale_install_paths=
gale_install_specs=
gale_need_update_log=

read -r profile < "$gale_profile_file"

is_normalized_path() {
  case /$1/ in
    *//*|*/./*|*/../*) return 1 ;;
    *) return 0 ;;
  esac
}

str_contains() {
  case $1 in
    *"$2"*) return 0 ;;
    *) return 1 ;;
  esac
}

link() {
  local target path
  target=$1
  path=$2
  gale_install_paths="${gale_install_paths} ${path}"
  gale_install_specs="${gale_install_specs} ${path}=${target}"
}

linkbin() {
  local target path
  target=$1
  path=".local/bin/${target##*/}"
  gale_install_paths="${gale_install_paths} ${path}"
  gale_install_specs="${gale_install_specs} ${path}=${target}"
}

. .gale/install.sh

if [ -e "$gale_log_file" ]; then
  while read -r path; do
    gale_log_paths="${gale_log_paths} ${path}"
  done < "$gale_log_file"
fi

# delete paths in log that are no longer in install.sh
for path in $gale_log_paths; do
  # if the path is in install.sh, skip it
  case " $gale_install_paths " in
    *" $path "*) continue ;;
  esac

  if [ -L "$path" ]; then
    msg "Removing $path"
    if [ -z "$dryrun" ]; then
      rm "$path"
      # remove empty parent directories if necessary
      case $path in
        */*) rmdir -p "${path%/*}" >/dev/null 2>&1 ;;
      esac
    fi
  else
    msg "Ignoring $path"
  fi
  gale_need_update_log=1
done

fail=0

for spec in $gale_install_specs; do
  path=${spec%%=*}
  target=${spec#*=}

  # generate the target for the symlink
  # the symlink should be relative and point to a path in ~/.gale
  target=".gale/$target"
  tmp=$path
  while str_contains "$tmp" /; do
    target="../$target"
    tmp=${tmp#*/}
  done

  # compare the expected target to the actual target
  if real_target=$(readlink "$path"); then
    if [ "$real_target" = "$target" ]; then
      if [ -n "$verbose" ]; then
        msg "Skipping: $path"
      fi
    else
      msg "Correcting symlink: $path -> $target"
      if [ -z "$dryrun" ]; then
        ln -sfT "$target" "$path" || fail=1
      fi
    fi
  else
    msg "Creating symlink: $path -> $target"
    if [ -z "$dryrun" ]; then
      if str_contains "$path" /; then
        mkdir -p "${path%/*}"
      fi
      ln -sT "$target" "$path" || fail=1
    fi
  fi

  case " $gale_log_paths " in
    *" $path "*) ;;
    *) gale_need_update_log=1 ;;
  esac
done

if [ "$gale_need_update_log" ]; then
  msg "Updating log..."
  if [ -z "$dryrun" ]; then
    if str_contains "$gale_log_file" /; then
      mkdir -p "${gale_log_file%/*}"
    fi
    printf '%s\n' $gale_install_paths > "$gale_log_file.tmp"
    mv "$gale_log_file.tmp" "$gale_log_file"
  fi
fi

exit $fail
