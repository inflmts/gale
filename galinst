#!/bin/sh
# Gale installer

set -uf

echo() { printf '%s\n' "$*"; }
msg() { printf >&2 '%s\n' "$*"; }
warn() { printf >&2 'warning: %s\n' "$*"; }
err() { printf >&2 'error: %s\n' "$*"; }

usage() {
  cat >&2 <<EOF
usage: galinst [<options>...]

Install Gale.

Options:
  -n, --dry-run   don't do anything, only show what would happen
  -v, --verbose   show skipped files as well
  -h, --help      show this help
EOF
}

dryrun=
verbose=

while [ $# -gt 0 ]; do
  case $1 in
    -[!-]?*)
      rest=${1#-?}
      cur=${1%"$rest"}
      shift
      set -- "$cur" "-$rest" "$@"
      continue
      ;;
    -n|--dry-run)
      dryrun=1
      ;;
    -v|--verbose)
      verbose=1
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      err "invalid option: $1"
      msg "Run 'galinst --help' for more information."
      exit 1
      ;;
  esac
  shift
done

# everything is relative to the home directory
cd || exit 1

gale_install_file="gale/install.conf"
gale_profile_file=".config/gale/profile"
gale_log_file=".data/gale/install.log"

install_paths=
install_specs=
need_update_log=

read -r profile < "$gale_profile_file"

is_valid_src_path() {
  # the path may not have any empty, '.', or '..' components
  case /$1/ in *//* | */./* | */../*) return 1 ;; esac
  # the path may only contain characters in the allowed set
  case $1 in *[!/0-9A-Za-z._-]*) return 1 ;; esac
  return 0
}

is_valid_dest_path() {
  # the path may not have any empty, '.', or '..' components
  case /$1/ in *//* | */./* | */../*) return 1 ;; esac
  # the path may only contain characters in the allowed set
  case $1 in *[!/0-9A-Za-z._-]*) return 1 ;; esac
  # the path must begin with a dot
  case $1 in .*) ;; *) return 1 ;; esac
  return 0
}

str_contains() {
  case $1 in
    *"$2"*) return 0 ;;
    *) return 1 ;;
  esac
}

add_spec() {
  local src dest
  src="$1"
  dest="$2"
  install_paths="${install_paths} ${dest}"
  install_specs="${install_specs} ${src} ${dest}"
}

# parse the config file

parse_error() {
  err "line $line_num: $1"
  exit 1
}

parse_exact_args() {
  if [ $1 -ne $2 ]; then
    parse_error "expected $2 argument(s)"
  fi
}

parse_check_src_path() {
  if ! is_valid_src_path "$1"; then
    parse_error "invalid source path '$1'"
  fi
}

parse_check_dest_path() {
  if ! is_valid_dest_path "$1"; then
    parse_error "invalid destination path '$1'"
  fi
}

line_num=0
log=
manifest=

while read -r line; do
  line_num=$((line_num + 1))
  set -- $line
  # skip empty lines
  if [ $# -eq 0 ]; then
    continue
  fi
  command=$1
  shift
  case $command in
    '#'*)
      ;;
    link)
      parse_exact_args $# 2
      src=$1
      parse_check_src_path "$src"
      dest=$2
      parse_check_dest_path "$dest"
      add_spec "$src" "$dest"
      ;;
    linkbin)
      parse_exact_args $# 1
      src=$1
      parse_check_src_path "$src"
      dest=".local/bin/${1##*/}"
      add_spec "$src" "$dest"
      ;;
    *)
      parse_error "unrecognized command: $command"
      ;;
  esac
done < "$gale_install_file" || exit 1

if [ -z "$install_paths" ]; then
  err "manifest is empty"
  exit 1
fi

# load log file
gale_log_paths=
if [ -e "$gale_log_file" ]; then
  while read -r path; do
    if is_valid_dest_path "$path"; then
      gale_log_paths="${gale_log_paths} ${path}"
    else
      warn "invalid path in log: $path"
    fi
  done < "$gale_log_file"
fi

# delete paths in log that are no longer in the manifest
for path in $gale_log_paths; do
  if str_contains " $install_paths " " $path "; then
    continue
  fi
  if [ -L "$path" ]; then
    msg "Removing $path"
    if [ -z "$dryrun" ]; then
      rm "$path"
      # remove empty parent directories if necessary
      if str_contains "$path" /; then
        rmdir -p "${path%/*}" >/dev/null 2>&1
      fi
    fi
  else
    msg "Ignoring $path"
  fi
  need_update_log=1
done

fail=0

set -- $install_specs
while [ $# -ge 2 ]; do
  src=$1
  dest=$2
  shift 2

  # generate the target for the symlink
  # the symlink should be relative and point to a path in ~/gale
  target="gale/$src"
  tmp=$dest
  while str_contains "$tmp" /; do
    target="../$target"
    tmp=${tmp#*/}
  done

  # compare the expected target to the actual target
  if real_target=$(readlink "$dest"); then
    if [ "$real_target" = "$target" ]; then
      if [ -n "$verbose" ]; then
        msg "Skipping: $dest"
      fi
    else
      msg "Correcting symlink: $dest -> $target"
      if [ -z "$dryrun" ]; then
        ln -sfT "$target" "$dest" || fail=1
      fi
    fi
  else
    msg "Creating symlink: $dest -> $target"
    if [ -z "$dryrun" ]; then
      if str_contains "$dest" /; then
        mkdir -p "${dest%/*}"
      fi
      ln -sT "$target" "$dest" || fail=1
    fi
  fi

  if ! str_contains " $gale_log_paths " " $dest "; then
    need_update_log=1
  fi
done

if [ "$need_update_log" ]; then
  msg "Updating log..."
  if [ -z "$dryrun" ]; then
    if str_contains "$gale_log_file" /; then
      mkdir -p "${gale_log_file%/*}"
    fi
    printf '%s\n' $install_paths > "$gale_log_file.tmp"
    mv "$gale_log_file.tmp" "$gale_log_file"
  fi
fi

exit $fail
